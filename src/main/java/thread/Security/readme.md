1．线程安全问题出现的原因?
存在多个线程在同时执行
同时访问一个共享资源
存在修改该共享资源

-----------------------------------------
线程同步：
1、同步代码块
    作用:把访问共享资源的核心代码给上锁，以此保证线程安全。
   ` synchronized(同步锁){
    访问共享资源的核心代码
    )
`
同步锁如果是常量的话，将会锁住所有的对象
比如黑白和红明两家人取钱只有一个人才能取

所以建议使用`this`来作为锁

但是静态方法建议用`类名.class`

------------------------------------
2.同步方法

`修饰符 synchronized 返回值类型 方法名称(形参列表){
操作共享资源的代码
}`

实例方法 this 作为锁

静态方法 是`类名.class`

同步代码块的性能更好，因为可以把其他不用锁住的代码先执行
---------------------------------------------

3.lock锁

Lock锁是JDK5开始提供的一个新的锁定操作，通过它可以创建出锁对象进行加锁和解锁，更灵活、更方便、更强大。

Lock是接口，不能直接实例化，可以采用它的实现类ReentrantLock来构建Lock锁对象。

构造器                         说明
`public ReentrantLock()`   获得Lock锁的实现类对象

Lock的常用方法                   
方法名称                    说明
`void lock()  `           获得锁
`void unlock()`           释放锁

